


Dette er koden jeg har skrevet til nå:

Subsekvens.java:
```
/**
 * Klassen Subsekvens kan ta vare på en subsekvens (en String) og et antall (et heltall som angir
 * antall forekomster av denne subsekvensen hos flere personer)
 */
public class Subsekvens {

  public final String subsekvens;
  private int antall;

  /** Opprett subsekvens */
  public Subsekvens(String subsekvens, int antall) {
    this.subsekvens = subsekvens;
    this.antall = antall;
  }

  /** Returner antall forekomster av subsekvensen. */
  public int getAntall() {
    return antall;
  }

  /** Legg til forekomster */
  public void leggTilAntall(int antall) {
    this.antall += antall;
  }

  @Override
  public String toString() {
    return "(" + subsekvens + "," + antall + ")";
  }
}
```

SubsekvensRegister.java:
```
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

/** En beholder som kan ta vare på mange HashMaps som inneholder subsekvenser */
public class SubsekvensRegister {

  private ArrayList<HashMap<String, Subsekvens>> register;

  /** Opprett et register */
  public SubsekvensRegister() {
    register = new ArrayList<>();
  }

  /** Legg en hashMap (alle subsekvensene til én person) til i register */
  public void leggTilHashMap(HashMap<String, Subsekvens> hashMap) {
    register.add(hashMap);
  }

  /** Returner og fjern hashMap fra register */
  public HashMap<String, Subsekvens> taUtHashMap() {
    if (register.isEmpty()) {
      return null;
    }
    return register.remove(0);
  }

  /** Returner antall hashMaps i register */
  public int antallHashMaps() {
    return register.size();
  }

  /** Les fil med substrenger (én persons blodprøve) og lag og returner hashMap */
  public static HashMap<String, Subsekvens> lesFil(String filnavn) {
    HashMap<String, Subsekvens> hashMap = new HashMap<>();

    try (Scanner scanner = new Scanner(new File(filnavn))) {
      while (scanner.hasNextLine()) {
        String linje = scanner.nextLine();
        if (linje.length() < 3) {
          System.err.println("Linje for kort: " + linje);
          System.exit(1);
        }
        for (int i = 0; i <= linje.length() - 3; i++) {
          String subsekvens = linje.substring(i, i + 3);
          if (!hashMap.containsKey(subsekvens)) {
            hashMap.put(subsekvens, new Subsekvens(subsekvens, 1));
          }
        }
      }
    } catch (FileNotFoundException e) {
      e.printStackTrace();
      System.exit(1);
    }

    return hashMap;
  }

  /** Slå sammen og returner to to hashMaps */
  public static HashMap<String, Subsekvens> flettHashMap(
      HashMap<String, Subsekvens> hashMap1, HashMap<String, Subsekvens> hashMap2) {
    HashMap<String, Subsekvens> nyHashMap = new HashMap<>();

    /** Itererer gjennom subsekvensene i hashMap1, og legger til i ny hashMap */
    for (String subsekvens : hashMap1.keySet()) {
      Subsekvens ss1 = hashMap1.get(subsekvens);
      Subsekvens ss2 = hashMap2.get(subsekvens);

      if (ss2 == null) {
        nyHashMap.put(subsekvens, new Subsekvens(subsekvens, ss1.getAntall()));
      } else {
        nyHashMap.put(subsekvens, new Subsekvens(subsekvens, ss1.getAntall() + ss2.getAntall()));
      }
    }

    /**
     * Itererer gjennom subsekvensene i hashMap2, og legger de resterende hashMapene til i nyHashMap
     */
    for (String subsekvens : hashMap2.keySet()) {
      if (!hashMap1.containsKey(subsekvens)) {
        Subsekvens ss2 = hashMap2.get(subsekvens);
        nyHashMap.put(subsekvens, new Subsekvens(subsekvens, ss2.getAntall()));
      }
    }

    return nyHashMap;
  }
}
```

Oblig5Del2A:
```
import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

/** Testprogram: finn subsekvensen med flest forekomster blant alle filer i oppgitt mappe */
public class Oblig5Del2A {

  /** Kjør programmet */
  public static void main(String[] args) {
    if (args.length != 1) {
      System.err.println("Bruk: java Oblig5Del1 <mappe med datafiler>");
      System.exit(1);
    }

    String dataMappe = args[0];
    ArrayList<HashMap<String, Subsekvens>> hashMapListe = new ArrayList<>();

    // Les inn alle filene og lag en hashMap for hver
    try (Scanner scanner = new Scanner(new File(dataMappe, "metadata.csv"))) {
      while (scanner.hasNextLine()) {
        String filnavn = scanner.nextLine().trim();
        HashMap<String, Subsekvens> hashMap =
            SubsekvensRegister.lesFil(new File(dataMappe, filnavn).getPath());
        hashMapListe.add(hashMap);
      }
    } catch (FileNotFoundException e) {
      e.printStackTrace();
      System.exit(1);
    }

    // Flett hashMap-ene sammen til én
    while (hashMapListe.size() > 1) {
      HashMap<String, Subsekvens> hashMap1 = hashMapListe.remove(0);
      HashMap<String, Subsekvens> hashMap2 = hashMapListe.remove(0);
      HashMap<String, Subsekvens> nyHashMap = SubsekvensRegister.flettHashMap(hashMap1, hashMap2);
      hashMapListe.add(nyHashMap);
    }

    // Finn subsekvensen med flest forekomster
    HashMap<String, Subsekvens> sisteHashMap = hashMapListe.get(0);
    Subsekvens mestFrekvente = null;
    for (Subsekvens subsekvens : sisteHashMap.values()) {
      if (mestFrekvente == null || subsekvens.getAntall() > mestFrekvente.getAntall()) {
        mestFrekvente = subsekvens;
      }
    }

    System.out.println("Mest frekvente subsekvens: " + mestFrekvente);
  }
}
```


Her er filtreet til prosjektet:
.
├── Oblig5Del2A.java
├── Subsekvens.java
├── SubsekvensRegister.java
├── TestDataLike
│   ├── fil1.csv
│   ├── fil2.csv
│   ├── fil3.csv
│   ├── fil4.csv
│   ├── fil5.csv
│   ├── fil6.csv
│   ├── fil7.csv
│   ├── fil8.csv
│   ├── fil9.csv
│   └── metadata.csv
├── TestDataLitenLike
│   ├── fil1.csv
│   ├── fil2.csv
│   ├── fil3.csv
│   └── metadata.csv
└── tekst.txt


Og her er et eksempel på innholdet i en metadatafil:
```
fil1.csv
fil2.csv
fil3.csv
fil4.csv
fil5.csv
fil6.csv
fil7.csv
fil8.csv
fil9.csv
```



Ved hjelp av komposisjon, bygg en monitor rundt SubsekvensRegisteret, slik at
bare én tråd kan sette inn en HashMap om gangen. Kall monitoren Monitor1.
Monitor1 skal tilby akkurat de samme metodene som SubsekvensRegister. Tips: Husk
at komposisjon betyr sammensetning. Monitor1 skal derfor ikke implementere
metodene fra SubsekvensRegister på nytt, men inneholde en peker til et
SubsekvensRegister-objekt og kalle metodene i dette objektet (delegere).

Kan du også implementere Runnable og locks til å løse oppgaven?

Skriv en trådklasse, kalt LeseTrad, som leser en fil og legger den resulterende
HashMap-en inn i en beholder av klassen Monitor1. En referanse til filnavnet og
en referanse til monitoren skal være parametre til konstruktøren til klassen.

Skriv om Oblig5Del2A slik at main-metoden starter opp mange tråder for å lese
alle filene og legge de resulterende HashMap-ene inn i ett (og det samme)
objektet av klassen Monitor1 (steg 1 i algoritmen). Det enkleste er å starte opp
en tråd for hver fil. Når alle disse trådene er ferdig, skal main-metoden
fortsette, og flette alle de resulterende HashMap-ene (del 2 i algoritmen) på
samme måte som i oppgavene 4 og 5, eneste forskjell er at nå ligger HashMap-ene
som skal flettes inne i Monitor1-objektet. Men siden bare én tråd (main-tråden)
foretar fletting behøver ikke metodene som henter ut HashMap-er fra Monitor1
beskyttes mot bruk fra flere tråder samtidig.

Legg main-metoden i en klasse du kaller Oblig5Del2A.java. Retteren din skal
kunne kompilere og kjøre programmet og bruke stien (folder og filnavn) til sine
datafiler som parameter til programmet.
